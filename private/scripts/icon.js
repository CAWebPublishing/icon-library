#!/usr/bin/env node

/**
 * External dependencies
 */
import fs from 'fs';
import path from 'path';
import { optimize, loadConfig } from 'svgo';
import { parseSync } from 'svgson';

// Constants
const nameSpace = 'caweb';
const privatePath = path.join(process.cwd(), 'private');

const srcPath = path.join(process.cwd(), 'src');
const iconsPath = path.join(srcPath, 'icons');
const integrationsPath = path.join(srcPath, 'integrations');

// SVGO Config
const svgoConfig = await loadConfig( path.join( privatePath, 'configs', 'svgo.config.js' ) );

// Main SVG file
const mainSVGFile = fs.readdirSync( path.join( srcPath, 'fonts' ), { recursive: true } ).filter( (e) => e.endsWith( '.svg' ) )[0];
const mstrSVGContent = fs.readFileSync(path.join( srcPath, 'fonts', mainSVGFile )).toString();
const mstrSVG = parseSync( optimize( mstrSVGContent, svgoConfig ).data );

// Base jsx template file
const baseJSX = fs.readFileSync( path.join( privatePath, 'templates', 'base.tsx.template' ) ).toString();

// master svg definition list
const mstrFontDefs = mstrSVG.children.filter( e => 'defs' === e.name )[0].children[0].children;
const mstrFontList = mstrFontDefs.filter(e => 'glyph' === e.name);

// we use this value for the svg viewBox attribute
const unitsPerEM = mstrFontDefs.filter( e => 'font-face' === e.name )[0].attributes['units-per-em'];
const descent = mstrFontDefs.filter( e => 'font-face' === e.name )[0].attributes['descent'];
const viewBox = `0 ${descent} ${unitsPerEM} ${unitsPerEM}`;

// we clear the icons folder before writing new files
// this will eliminate any old files that are not in the new set of icons
fs.rmSync( iconsPath, { recursive: true, force: true } );

// icon index file content
let indexContent = [`// Autogenerated file, do not edit directly\n`];

// Add any integrations here
import { iconImports, outputIntegrationFile } from './integrations/divi.ts';

// loop through the SVG file list and create a new file for each icon
mstrFontList.forEach( (glyph) => { 
     // glyph attributes

     let { 
          'glyph-name': name, 
          'data-tags': tags, 
          'd' : dimensions,
          'unicode': decodedUnicode
     } = glyph.attributes;
     
     // if the name is not defined we skip it
     if( ! name ){
          return;
     }

     // We get the encoded unicode value from the master svg content file, otherwise the glyph renders the icon not the unicode value
     let matches = mstrSVGContent.match( new RegExp( `unicode="(.*)" glyph-name="${name}"` ) );

     // if there is a match we can continue
     if( matches ){
          // remove the name from the tags.
          tags = tags ? tags.replace( name, '' ) : '';

          let iconDir = path.join( iconsPath, name );
          
          // create the output directory if it doesn't exist
          if (  ! fs.existsSync( iconDir ) ) {
               fs.mkdirSync( iconDir, { recursive: true } );
          }

          let svg = optimize(
               `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}"><path d="${dimensions}"></path></svg>`,
               svgoConfig
          ).data;

          // output the optimized SVG file
          fs.writeFileSync( 
               path.join(iconDir, `${name}.svg`), 
               `<!-- ${name} icon -->\n${svg}`
          );

          // output the icon tsx file
          fs.writeFileSync( 
               path.join( iconDir, `${name}.tsx`), 
               baseJSX
                    .replaceAll( '{nameSpace}', nameSpace )
                    .replaceAll( '{name}', name )
                    .replaceAll( '{viewBox}', viewBox )
                    .replaceAll( '{dimensions}', dimensions )
          );

          // output the icon json file
          fs.writeFileSync( 
               path.join( iconDir, `${name}.json`), 
               JSON.stringify( 
                    {
                         name: `${nameSpace}/${name}`,
                         decodedUnicode,
                         unicode: matches[1],
                         fontWeight: parseInt( 400 ),
                         styles: tags ? tags.split( ',' ) : [],
                         searchTerms: [nameSpace, name, tags.split( ',' )].join(','),
                    }, 
                    null, 4 
               ) 
          );

          // add the import to the index file
          let exportName = name.replaceAll(/[-_]([\w]{1})/g, (m, g) => g.toUpperCase());
          indexContent.push( `export * as ${exportName} from './${name}/${name}';\n` );
          iconImports.push( exportName );
     }else{
          console.log( `Icon ${name} not found in master SVG file` );
          console.log( 'Glyph Data:', glyph );
     }
});

// write the index.ts file
fs.writeFileSync(
     path.join( iconsPath, 'index.ts' ),
     indexContent.join( '' )
);

// create the output directory if it doesn't exist
if (  ! fs.existsSync( integrationsPath ) ) {
     fs.mkdirSync( integrationsPath, { recursive: true } );
}

// write the divi.ts integration file
fs.writeFileSync(
     path.join( integrationsPath, 'divi.ts' ),
     outputIntegrationFile()
 );